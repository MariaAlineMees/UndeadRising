package br.com.pedrodamasceno.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap; // Novo import para HashMap
import java.util.List;
import java.util.Map;    // Novo import para Map
import java.util.Random;

import br.com.pedrodamasceno.model.itens.ArmaDeFogo;
import br.com.pedrodamasceno.model.itens.Item; // Importar a classe Mapa
import br.com.pedrodamasceno.model.itens.Mapa;
import br.com.pedrodamasceno.model.locais.Local; // Importar a classe SubLocal
import br.com.pedrodamasceno.model.locais.SubLocal;
import br.com.pedrodamasceno.model.personagens.Personagem;
import br.com.pedrodamasceno.model.zumbis.BossFinal;
import br.com.pedrodamasceno.model.zumbis.Zumbi;
import br.com.pedrodamasceno.model.zumbis.ZumbiCachorro;
import br.com.pedrodamasceno.model.zumbis.ZumbiComum;
import br.com.pedrodamasceno.model.zumbis.ZumbiCorredor;
import br.com.pedrodamasceno.model.zumbis.ZumbiEstrategista;
import br.com.pedrodamasceno.model.zumbis.ZumbiKamikaze;
import br.com.pedrodamasceno.model.zumbis.ZumbiNoturno;
import br.com.pedrodamasceno.model.zumbis.ZumbiTanque; // Importar ArmaDeFogo
import br.com.pedrodamasceno.model.zumbis.ZumbiToxico;

public class ModeloJogo {
    private Personagem jogador;
    private int diaAtual;
    private ConfrontoFinal confrontoFinal;
    private PeriodoDia periodoAtual;
    private boolean emCombate;
    private boolean jogoTerminado;
    private boolean jogoVencido;
    private boolean eventoFinalAtivo;
    private boolean emSelecaoSubLocal; // Novo campo para controlar a seleção de sublocais
    private SubLocal subLocalAtual; // Novo campo para armazenar o sublocal atual
    private String resumoDiaAnterior; // Novo campo para armazenar o resumo do dia anterior

    // CONTROLE SIMPLIFICADO DE EXPLORAÇÃO
    private boolean dormiu = false;
    private int exploracoesDiaAtual; // Novo campo para contar as explorações diárias

    private final List<Local> locaisBase = new ArrayList<>();
    private List<Local> locaisDoDia = new ArrayList<>(3);
    private Local localAtual;
    private List<Zumbi> inimigosAtuais = new ArrayList<>();
    private String mensagem;

    // Novos campos para locais fixos
    private Local localDia1Fixo;
    private Local localDia7Fixo;

    // NOVO: Map para armazenar prioridades de itens por local
    private final Map<String, List<Integer>> itemPrioridadesPorLocal;

    public ModeloJogo() {
        this.diaAtual = 1;
        this.periodoAtual = PeriodoDia.MANHA;
        this.emCombate = false;
        this.jogoTerminado = false;
        this.jogoVencido = false;
        this.eventoFinalAtivo = false;
        this.emSelecaoSubLocal = false; // Inicializa como falso
        this.subLocalAtual = null; // Inicializa como nulo
        this.resumoDiaAnterior = ""; // Inicializa com string vazia
        this.mensagem = "Bem-vindo ao Apocalipse Zumbi! Escolha seu personagem.";
        this.exploracoesDiaAtual = 0; // Inicializa o contador de explorações diárias
        inicializarLocaisBase();
        sortearLocaisDoDia();
        // NOVO: Inicializar e popular o map de prioridades de itens
        itemPrioridadesPorLocal = new HashMap<>();
        popularPrioridadesItensPorLocal();
    }

    private void inicializarLocaisBase() {
        // Locais fixos
        localDia1Fixo = new Local("Distrito Residencial - Bairro Esperança", "As casas estão vazias, portas rangem com o vento e o silêncio é quase perturbador. A sensação é de que a qualquer momento algo pode espreitar das sombras.", 4);
        localDia1Fixo.addSubLocal(new SubLocal("Garagem Velha", "Pode ter ferramentas ou esconderijos.", 3));
        localDia1Fixo.addSubLocal(new SubLocal("Carro de Luxo Abandonado", "Talvez itens de valor, mas arriscado.", 5));
        localDia1Fixo.addSubLocal(new SubLocal("Parque Infantil Destruído", "Restos de brinquedos, fácil de ver, mas barulhento.", 2));
        locaisBase.add(localDia1Fixo);

        localDia7Fixo = new Local("Ponto Alfa - Ponto Alfa", "O ambiente transmite tensão imediata: cada passo parece ecoar mais alto, como se fosse impossível permanecer despercebido.", 10);
        locaisBase.add(localDia7Fixo);

        // Outros locais (não fixos)
        Local supermercado = new Local("Supermercado", "Comida e suprimentos.", 4);
        supermercado.addSubLocal(new SubLocal("Corredor de Alimentos", "Prateleiras vazias, restos de embalagens.", 3));
        supermercado.addSubLocal(new SubLocal("Estoque dos Fundos", "Caixas empilhadas, pouca luz.", 5));
        supermercado.addSubLocal(new SubLocal("Caixas Registradoras", "Dinheiro espalhado, alarmes quebrados.", 4));
        locaisBase.add(supermercado);

        Local hospital = new Local("Hospital", "Remédios, muitos zumbis.", 7);
        hospital.addSubLocal(new SubLocal("Recepção", "Mesas viradas, papéis espalhados.", 6));
        hospital.addSubLocal(new SubLocal("Farmácia Hospitalar", "Armários de remédios, mas com risco.", 7));
        hospital.addSubLocal(new SubLocal("Enfermaria", "Camas vazias, sangue seco.", 8));
        locaisBase.add(hospital);

        Local delegacia = new Local("Delegacia", "Possível encontrar armas.", 5);
        delegacia.addSubLocal(new SubLocal("Sala de Armas", "Armários de armas, mas trancados.", 7));
        delegacia.addSubLocal(new SubLocal("Celas", "Portas abertas, cheiro de decomposição.", 6));
        delegacia.addSubLocal(new SubLocal("Escritórios", "Documentos, mesas viradas.", 4));
        locaisBase.add(delegacia);

        Local casaAbandonada = new Local("Casa Abandonada", "Abrigo temporário.", 3);
        casaAbandonada.addSubLocal(new SubLocal("Cozinha", "Restos de comida, louça quebrada.", 2));
        casaAbandonada.addSubLocal(new SubLocal("Quartos", "Roupas espalhadas, móveis revirados.", 3));
        casaAbandonada.addSubLocal(new SubLocal("Jardim", "Vegetação alta, ferramentas de jardim.", 1));
        locaisBase.add(casaAbandonada);

        Local farmacia = new Local("Farmácia", "Remédios e curativos.", 4);
        farmacia.addSubLocal(new SubLocal("Prateleiras de Remédios", "Caixas vazias, alguns remédios intactos.", 3));
        farmacia.addSubLocal(new SubLocal("Fundos da Farmácia", "Depósito pequeno, talvez algo útil.", 4));
        locaisBase.add(farmacia);

        Local postoDeGasolina = new Local("Posto de Gasolina", "Risco de explosão.", 6);
        postoDeGasolina.addSubLocal(new SubLocal("Loja de Conveniência", "Comida, bebida, pilhas.", 5));
        postoDeGasolina.addSubLocal(new SubLocal("Bombas de Combustível", "Perigoso, mas pode haver combustível.", 7));
        locaisBase.add(postoDeGasolina);

        Local escola = new Local("Escola", "Recursos e perigos.", 5);
        escola.addSubLocal(new SubLocal("Salas de Aula", "Livros, mochilas, talvez material escolar.", 4));
        escola.addSubLocal(new SubLocal("Biblioteca", "Livros, mapas, talvez informações.", 5));
        escola.addSubLocal(new SubLocal("Quadra Esportiva", "Espaço aberto, bom para visibilidade.", 3));
        locaisBase.add(escola);

        Local igreja = new Local("Igreja", "Mais seguro de dia.", 3);
        igreja.addSubLocal(new SubLocal("Nave Principal", "Bancos revirados, vitrais quebrados.", 2));
        igreja.addSubLocal(new SubLocal("Cripta", "Escuro, úmido, talvez algo escondido.", 6));
        locaisBase.add(igreja);

        Local deposito = new Local("Depósito", "Itens úteis.", 5);
        deposito.addSubLocal(new SubLocal("Setor de Ferramentas", "Martelos, chaves, ferramentas variadas.", 4));
        deposito.addSubLocal(new SubLocal("Setor de Embalagens", "Caixas vazias, esconderijos.", 3));
        locaisBase.add(deposito);

        Local baseMilitar = new Local("Base Militar", "Perigoso, ótimos recursos.", 8);
        baseMilitar.addSubLocal(new SubLocal("Arsenal", "Muitas armas, mas fortemente guardado.", 9));
        baseMilitar.addSubLocal(new SubLocal("Quartel", "Camas, pertences de soldados.", 7));
        locaisBase.add(baseMilitar);
    }

    // NOVO: Método para popular o map de prioridades de itens por local
    private void popularPrioridadesItensPorLocal() {
        // Hospital: Medicamentos
        itemPrioridadesPorLocal.put("Hospital", List.of(1, 2, 3, 9, 11));
        // Farmácia: Medicamentos
        itemPrioridadesPorLocal.put("Farmácia", List.of(1, 2, 3, 9, 11, 15)); // Inclui Kit de Primeiros Socorros
        // Base Militar: Armas, Munição, Explosivos
        itemPrioridadesPorLocal.put("Base Militar", List.of(4, 5, 6, 7, 8, 14, 15)); // Inclui Granada
        // Delegacia: Armas, Munição
        itemPrioridadesPorLocal.put("Delegacia", List.of(4, 5, 6, 7, 8));
        // Supermercado: Comida, Ração de Combate
        itemPrioridadesPorLocal.put("Supermercado", List.of(0, 10));
        // Depósito: Armas (Faca), Armaduras, Lanterna Tática
        itemPrioridadesPorLocal.put("Depósito", List.of(4, 12, 13));
        // Carro de Luxo Abandonado: Itens de valor (Pistola, Rifle)
        itemPrioridadesPorLocal.put("Carro de Luxo Abandonado", List.of(5, 7));
        // Garagem Velha: Ferramentas (Faca, Isqueiro e Spray)
        itemPrioridadesPorLocal.put("Garagem Velha", List.of(4, 14));
    }

    private void sortearLocaisDoDia() {
        // Locais do Dia 1 e Dia 7 são fixos
        if (diaAtual == 1) {
            locaisDoDia = List.of(localDia1Fixo); // Apenas o local fixo do dia 1
            localAtual = localDia1Fixo;
        } else if (diaAtual == 7) {
            locaisDoDia = List.of(localDia7Fixo); // Apenas o local fixo do dia 7
            localAtual = localDia7Fixo;
        } else {
            // Para dias intermediários, sortear 3 locais (excluindo os fixos)
            List<Local> locaisIntermediarios = new ArrayList<>(locaisBase);
            locaisIntermediarios.remove(localDia1Fixo);
            locaisIntermediarios.remove(localDia7Fixo);
            Collections.shuffle(locaisIntermediarios, new Random());
            locaisDoDia = new ArrayList<>(locaisIntermediarios.subList(0, Math.min(3, locaisIntermediarios.size())));
            localAtual = null; // Definir como null para que o jogador precise selecionar o local
        }
    }

    public void iniciarNovoJogo(Personagem jogador) {
        this.jogador = jogador;
        this.diaAtual = 1;
        this.periodoAtual = PeriodoDia.MANHA;
        this.emCombate = false;
        this.jogoTerminado = false;
        this.jogoVencido = false;
        this.eventoFinalAtivo = false;
        this.emSelecaoSubLocal = false; // Inicializa como falso
        this.subLocalAtual = null; // Inicializa como nulo
        this.resumoDiaAnterior = ""; // Inicializa com string vazia

        // RESETAR CONTROLES
        this.exploracoesDiaAtual = 0; // Reseta o contador de explorações

        this.mensagem = "Dia 1 - Manhã: " + obterDescricaoLocalDoDia(1) + "\nO que você faz?";

        if (jogador.getInventario() != null) {
            int cap = 3 + Math.max(0, jogador.getConstituicao());
            jogador.getInventario().setCapacidade(cap);
        }

        jogador.setSentimento("Determinado"); // Define o sentimento inicial do jogador
    }

    public void explorarLocal() {
        explorar();
    }

    public Map<String, Object> explorar() {
        Map<String, Object> resultados = new HashMap<>();
        resultados.put("combateIniciado", false);
        resultados.put("selecaoSubLocalIniciada", false);
        resultados.put("itemEncontrado", null);
        resultados.put("mensagemStatus", null); // Para mensagens de erro/estado

        if (eventoFinalAtivo) {
            resultados.put("mensagemStatus", "Dia 7 - Evento Final: Não é possível explorar. Enfrente o Boss!");
            return resultados;
        }
        if (emCombate) {
            resultados.put("mensagemStatus", "Você está em combate! Não pode explorar agora.");
            return resultados;
        }

        // Verificar limite de explorações diárias
        if (exploracoesDiaAtual >= 3) {
            setMensagem("Você já explorou 3 vezes neste dia. Agora você deve dormir para avançar para o próximo dia.");
            resultados.put("mensagemStatus", getMensagem());
            return resultados;
        }

        if (diaAtual > 10) {
            resultados.put("mensagemStatus", "Você já completou os 10 dias!");
            return resultados;
        }

        // Se o local atual tem sublocais, entrar em modo de seleção de sublocal
        if (!localAtual.getSubLocais().isEmpty()) {
            this.emSelecaoSubLocal = true;
            this.subLocalAtual = null; // Resetar subLocalAtual ao entrar em seleção de sublocal
            resultados.put("selecaoSubLocalIniciada", true);
            setMensagem("Você chegou em " + localAtual.getNome() + ". Escolha uma área para explorar:");
            return resultados;
        }
        
        // EXPLORAÇÃO NORMAL (se não tiver sublocais)
        localAtual.explorar();
        resultados.put("localExplorado", localAtual.getNome());
        resultados.put("periodo", periodoAtual.getRotulo());

        // VERIFICAR SE ENCONTROU ZUMBIS
        if (encontrarZumbis()) {
            resultados.put("combateIniciado", true);
            // Não marcar período como explorado se encontrou zumbis - será feito após o combate
            this.emSelecaoSubLocal = false; // Resetar após exploração normal (se iniciou combate)
            return resultados;
        }

        // VERIFICAR SE ENCONTROU ITEM
        Item itemEncontrado = encontrarItem(true);
        if (itemEncontrado != null) {
            resultados.put("itemEncontrado", itemEncontrado);
            jogador.atualizarSentimentoJogador(1); // Encontrar item bom, sentimento positivo
        }
        
        // Incrementar contador de explorações e avançar período (narrativo)
        exploracoesDiaAtual++;
        avancarPeriodo();
        this.emSelecaoSubLocal = false; // Resetar após exploração normal
        return resultados;
    }

    public void concluirExploracao() {
        exploracoesDiaAtual++;
        avancarPeriodo();
        this.emSelecaoSubLocal = false;
    }

    public Map<String, Object> explorarSubLocal(SubLocal subLocal) {
        Map<String, Object> resultados = new HashMap<>();
        resultados.put("combateIniciado", false);
        resultados.put("itemEncontrado", null);
        resultados.put("mensagemStatus", null);

        this.subLocalAtual = subLocal; // Definir o sublocal atual imediatamente

        if (eventoFinalAtivo || emCombate || subLocal == null) {
            resultados.put("mensagemStatus", "Não é possível explorar o sublocal agora.");
            return resultados;
        }

        // Verificar limite de explorações diárias para sublocal
        if (exploracoesDiaAtual >= 3) {
            setMensagem("Você já explorou 3 vezes neste dia. Agora você deve dormir para avançar para o próximo dia.");
            resultados.put("mensagemStatus", getMensagem());
            return resultados;
        }

        // Lógica de exploração do sublocal continua (geração de zumbis/itens)
        resultados.put("subLocalExplorado", subLocalAtual.getNome());
        resultados.put("localExplorado", localAtual.getNome());
        resultados.put("periodo", periodoAtual.getRotulo());

        // VERIFICAR SE ENCONTROU ZUMBIS NO SUBLOCAL
        if (encontrarZumbisSubLocal()) {
            resultados.put("combateIniciado", true);
            this.emSelecaoSubLocal = false; // Resetar após exploração de sublocal (se iniciou combate)
            return resultados;
        }

        // VERIFICAR SE ENCONTROU ITEM NO SUBLOCAL
        Item itemEncontrado = encontrarItem(true); // Usamos true porque é exploração, não combate
        if (itemEncontrado != null) {
            resultados.put("itemEncontrado", itemEncontrado);
            jogador.atualizarSentimentoJogador(1); // Encontrar item bom, sentimento positivo
        }
        
        // Incrementar contador de explorações e avançar período (narrativo)
        exploracoesDiaAtual++;
        avancarPeriodo();
        this.emSelecaoSubLocal = false; // Resetar após exploração de sublocal
         return resultados;
     }

    public boolean encontrarZumbisSubLocal() {
        // Gerar zumbis baseado no sublocal atual, dia e nível de perigo
        inimigosAtuais = gerarZumbisPorDificuldade(diaAtual, subLocalAtual.getNivelPerigo());
        if (!inimigosAtuais.isEmpty()) {
            emCombate = true;
            return true;
        }
        return false;
    }

    public boolean encontrarZumbis() {
        // Gerar zumbis baseado no dia atual e nível de perigo do local
        inimigosAtuais = gerarZumbisPorDificuldade(diaAtual, localAtual.getNivelPerigo());
        if (!inimigosAtuais.isEmpty()) {
            emCombate = true;
            return true;
        }
        return false;
    }
    
    private List<Zumbi> gerarZumbisPorDificuldade(int dia, int nivelPerigoAtual) {
        List<Zumbi> zumbis = new ArrayList<>();
        Random random = new Random();
        int chanceEncontroBase = 50; // Chance base de encontrar zumbis
        int maxZumbis = 1; // Número máximo de zumbis

        // Ajustar chance e maxZumbis com base no dia e nivelPerigoAtual
        chanceEncontroBase += (dia - 1) * 5; // Aumenta 5% por dia
        chanceEncontroBase += nivelPerigoAtual * 2; // Aumenta 2% por nível de perigo

        maxZumbis += (dia - 1) / 2; // Máximo de zumbis aumenta a cada 2 dias
        maxZumbis += nivelPerigoAtual / 3; // Máximo de zumbis aumenta a cada 3 níveis de perigo
        maxZumbis = Math.min(maxZumbis, 5); // Limitar o número máximo de zumbis

        // Encontro fixo para o Boss Final no Dia 7
        if (dia == 7) {
            zumbis.add(new BossFinal());
            return zumbis;
        }

        // Chance geral de encontrar zumbis
        if (random.nextInt(100) < chanceEncontroBase) {
            int numZumbis = 1 + random.nextInt(maxZumbis); // Pelo menos 1, até maxZumbis

            for (int i = 0; i < numZumbis; i++) {
                // Determinar tipo de zumbi com base no dia e nível de perigo
                int tipoZumbiChance = random.nextInt(100);

                if (dia == 1) { // Dia 1: Apenas Zumbi Comum
                    zumbis.add(new ZumbiComum());
                } else if (dia == 2) { // Dia 2: Comuns e Corredores
                    if (tipoZumbiChance < 60) { // 60% comum
                        zumbis.add(new ZumbiComum());
                    } else { // 40% corredor
                        zumbis.add(new ZumbiCorredor());
                    }
                } else if (dia == 3) { // Dia 3: Tóxicos, Comuns, Corredores
                    if (tipoZumbiChance < 40) { // 40% comum
                        zumbis.add(new ZumbiComum());
                    } else if (tipoZumbiChance < 70) { // 30% corredor
                        zumbis.add(new ZumbiCorredor());
                    } else { // 30% tóxico
                        zumbis.add(new ZumbiToxico());
                    }
                } else if (dia == 4) { // Dia 4: Tanques, Kamikazes, Tóxicos
                    if (tipoZumbiChance < 30) { // 30% toxico
                        zumbis.add(new ZumbiToxico());
                    } else if (tipoZumbiChance < 60) { // 30% tanque
                        zumbis.add(new ZumbiTanque());
                    } else { // 40% kamikaze
                        zumbis.add(new ZumbiKamikaze());
                    }
                } else if (dia == 5) { // Dia 5: Hordas de diferentes tipos
                    if (tipoZumbiChance < 20) { // 20% comum
                        zumbis.add(new ZumbiComum());
                    } else if (tipoZumbiChance < 40) { // 20% corredor
                        zumbis.add(new ZumbiCorredor());
                    } else if (tipoZumbiChance < 60) { // 20% toxico
                        zumbis.add(new ZumbiToxico());
                    } else if (tipoZumbiChance < 80) { // 20% tanque
                        zumbis.add(new ZumbiTanque());
                    } else { // 20% cachorro ou estrategista (mais raros)
                        if (random.nextBoolean()) {
                            zumbis.add(new ZumbiCachorro());
                        } else {
                            zumbis.add(new ZumbiEstrategista());
                        }
                    }
                } else if (dia == 6) { // Dia 6: Preparação para o boss, zumbis mais fortes
                    if (tipoZumbiChance < 25) { // 25% tanque
                        zumbis.add(new ZumbiTanque());
                    } else if (tipoZumbiChance < 50) { // 25% toxico
                        zumbis.add(new ZumbiToxico());
                    } else if (tipoZumbiChance < 75) { // 25% estrategista
                        zumbis.add(new ZumbiEstrategista());
                    } else { // 25% noturno (mais perigoso)
                        zumbis.add(new ZumbiNoturno());
                    }
                }
            }
        }
        
        return zumbis;
    }

    public Item encontrarItem(boolean isExploracao) {
        Random random = new Random();
        int chanceEncontrar = isExploracao ? 100 : 50; // 100% para exploração, 50% para pós-combate

        if (random.nextInt(100) < chanceEncontrar) {
            if (random.nextInt(100) < 40) { // 40% de chance de ser arma (dentro da chance de encontrar)
            Item arma = gerarArmaAleatoria();
            if (jogador.adicionarItem(arma)) {
                return arma;
            }
        } else {
            // Gerar itens baseados no dia/local
            Item item = gerarItemDoDia();
            if (item != null && jogador.adicionarItem(item)) {
                return item;
            }
        }
        }
        return null; // Não encontrou item ou inventário cheio
    }

    private Item gerarArmaAleatoria() {
        Random random = new Random();
        int tipo = random.nextInt(100);

        if (tipo < 50) {
            return new br.com.pedrodamasceno.model.itens.Arma("Faca", "Faca afiada de cozinha", 15, 5, 20);
        } else if (tipo < 80) {
            return new br.com.pedrodamasceno.model.itens.ArmaDeFogo("Pistola", "Pistola semi-automática", 30, 12, 8, 10); // Arma de Fogo com munição
        } else {
            return new br.com.pedrodamasceno.model.itens.ArmaDeFogo("Rifle", "Rifle de precisão", 50, 18, 5, 5); // Arma de Fogo com munição
        }
    }
    
    private Item gerarItemDoDia() {
        // No Dia 1, garantir que o jogador encontre o Mapa
        if (diaAtual == 1 && !jogador.getInventario().contemItem("Mapa")) {
            return new Mapa("Mapa", "Um mapa detalhado da região.");
        }

        Random random = new Random();
        int tipoItem;

        // NOVO: Lógica para priorizar itens com base no local atual
        String nomeLocalParaPrioridade = (subLocalAtual != null) ? subLocalAtual.getNome() : (localAtual != null ? localAtual.getNome() : null);

        if (nomeLocalParaPrioridade != null && itemPrioridadesPorLocal.containsKey(nomeLocalParaPrioridade)) {
            List<Integer> prioridades = itemPrioridadesPorLocal.get(nomeLocalParaPrioridade);
            // Dar uma chance maior de sortear um item da lista de prioridades
            if (random.nextInt(100) < 70 && !prioridades.isEmpty()) { // 70% de chance de priorizar
                tipoItem = prioridades.get(random.nextInt(prioridades.size()));
            } else {
                tipoItem = random.nextInt(16); // Sorteio normal se não priorizar
            }
        } else {
            tipoItem = random.nextInt(16); // Sorteio totalmente aleatório
        }

        // Removendo o antigo `int tipoItem = random.nextInt(16);` para evitar conflito
        // int tipoItem = random.nextInt(16); // Aumentado para 16 para incluir novos itens
        
        switch (tipoItem) {
            case 0: return new br.com.pedrodamasceno.model.itens.Item("Comida Enlatada", "Comida não perecível", br.com.pedrodamasceno.model.itens.TipoItem.COMIDA, 15);
            case 1: return new br.com.pedrodamasceno.model.itens.Medicamento("Medicamento de Cura Pequeno", "Cura 20 HP", 20);
            case 2: return new br.com.pedrodamasceno.model.itens.Medicamento("Medicamento de Cura Médio", "Cura 40 HP", 40);
            case 3: return new br.com.pedrodamasceno.model.itens.Medicamento("Medicamento de Cura Grande", "Cura 60 HP", 60);
            case 4: return new br.com.pedrodamasceno.model.itens.Arma("Faca", "Arma branca simples", 15, 8, 20);
            case 5: return new ArmaDeFogo("Revólver", "Arma de fogo básica", 30, 12, 10, 8); // Arma de fogo com munição e durabilidade
            case 6: return new ArmaDeFogo("Espingarda", "Curto alcance", 45, 18, 8, 5); // Arma de fogo com munição e durabilidade
            case 7: return new ArmaDeFogo("Rifle", "Longo alcance", 60, 22, 7, 5); // Arma de fogo com munição e durabilidade
            case 8: return new br.com.pedrodamasceno.model.itens.Item("Munição", "Munição para armas de fogo", br.com.pedrodamasceno.model.itens.TipoItem.MUNICAO, 10);
            case 9: return new br.com.pedrodamasceno.model.itens.Antidoto("Antídoto", "Remove efeitos de veneno e cura 10 HP.", 10); // Novo item
            case 10: return new br.com.pedrodamasceno.model.itens.RacaoCombate("Ração de Combate", "Cura 25 HP e aumenta Força por 2 turnos.", 5, 25, 3, 2); // Novo item
            case 11: return new br.com.pedrodamasceno.model.itens.AnalgesicoForte("Analgésico Forte", "Cura 30 HP e remove cansaço/medo.", 30); // Novo item
            case 12: return new br.com.pedrodamasceno.model.itens.Armadura("Colete Leve", "Oferece proteção básica.", 20, 5, 15); // Novo item
            case 13: return new br.com.pedrodamasceno.model.itens.LanternaTatica("Lanterna Tática", "Aumenta inteligência por 3 turnos.", 10, 2, 3); // Novo item
            case 14: return new br.com.pedrodamasceno.model.itens.IsqueiroESpray("Isqueiro e Spray", "Causa 20 de dano em área no combate.", 15, 20); // Novo item
            case 15: // Granada ou Kit de Primeiros Socorros
                if (diaAtual == 6) {
                    return new br.com.pedrodamasceno.model.itens.Item("Granada", "Explosivo de uso único (30 de dano em área)", br.com.pedrodamasceno.model.itens.TipoItem.EXPLOSIVO, 30);
                } else {
                    return new br.com.pedrodamasceno.model.itens.Medicamento("Kit de Primeiros Socorros", "Cura ferimentos", 30);
                }
            default: return new br.com.pedrodamasceno.model.itens.Item("Água", "Água potável", br.com.pedrodamasceno.model.itens.TipoItem.COMIDA, 10);
        }
    }

    public void dormir() {
        if (eventoFinalAtivo) { setMensagem("Dia 7 - Evento Final: Não é possível dormir durante o evento final."); return; }
        if (emCombate) { setMensagem("Você está em combate! Não pode dormir agora."); return; }

        if (dormiu) { setMensagem("Você já dormiu hoje!"); return; }

        if (exploracoesDiaAtual < 3) { setMensagem("Você precisa explorar 3 vezes antes de dormir!"); return; }

        dormiu = true;
        
        // Recuperar saúde ao dormir
        int saudeAntes = jogador.getSaude();
        jogador.curar(jogador.getSaudeMaxima() / 3); // Recupera 1/3 da saúde máxima
        int saudeRecuperada = jogador.getSaude() - saudeAntes;
        
        // Recuperar cargas das habilidades ao dormir
        jogador.setCargasHabilidade1(2); // HAB1 volta para 2 cargas
        jogador.setCargasHabilidade2(1); // HAB2 volta para 1 carga
        
        // Construir resumo do dia anterior
        StringBuilder resumo = new StringBuilder();
        resumo.append("Fim do Dia ").append(diaAtual).append("!\n");
        resumo.append("Saúde recuperada: ").append(saudeRecuperada).append(" HP.\n");
        // Mensagem da noite baseada no sentimento
        resumo.append(gerarMensagemNoite(jogador.getSentimento()));
        this.resumoDiaAnterior = resumo.toString();
        
        // Avançar automaticamente para o próximo dia
        avancarParaProximoDia();
        
        // Aplicar evento especial do dia (mensagem será adicionada ao log no ControladorJogo)
        aplicarEventoEspecialDoDia();
        String mensagemDormir = "Você dormiu e recuperou " + saudeRecuperada + " de saúde e suas habilidades. Pronto para o próximo dia!";
        // Se o próximo dia exigir seleção de local, adicionar o lembrete à mensagem
        if (diaAtual > 1 && diaAtual < 7) {
            mensagemDormir += "\nNão se esqueça de selecionar seu local para começar a explorar!";
        }
        setMensagem(mensagemDormir);
        this.emSelecaoSubLocal = false; // Sair do modo de seleção de sublocal após dormir
    }
    
    private void aplicarEventoEspecialDoDia() {
        // Aplicar evento especial baseado no dia
        if (diaAtual == 5) {
            setMensagem(getMensagem() + "\n\nEVENTO ESPECIAL: Os zumbis estão mais agressivos!");
        } else if (diaAtual == 7) {
            setMensagem(getMensagem() + "\n\nEVENTO ESPECIAL: Uma tempestade se aproxima, limitando a visibilidade!");
        } else if (diaAtual == 9) {
            setMensagem(getMensagem() + "\n\nEVENTO ESPECIAL: O Zumbi Alfa está próximo! Prepare-se para o confronto final!");
        }
    }
    
    private void avancarParaProximoDia() {
        // AVANÇAR PARA O PRÓXIMO DIA
        diaAtual++;
        jogador.aumentarDia();

        // RESETAR CONTROLES PARA O NOVO DIA
        periodoAtual = PeriodoDia.MANHA;
        dormiu = false;
        exploracoesDiaAtual = 0; // Reseta as explorações para o novo dia
        this.emSelecaoSubLocal = false; // Resetar para o próximo dia

        if (diaAtual == 7) {
            // Ativar evento final (Dia 7) - sem períodos/exploração
            eventoFinalAtivo = true;
            setMensagem("Dia 7 - Evento Final: O Boss final se aproxima! Prepare-se para o confronto.");
        } else if (!jogador.estaVivo()) {
            jogoTerminado = true;
            setMensagem("Você morreu! Fim de jogo.");
        } else {
            sortearLocaisDoDia(); // Sortear novos locais para o dia
            if (diaAtual > 1 && diaAtual < 7) {
                localAtual = null; // Reiniciar localAtual para forçar a seleção pelo jogador
                setMensagem("Dia " + diaAtual + " - Manhã: Não se esqueça de selecionar seu local para começar a explorar!\nO que você faz?");
            } else {
                setMensagem("Dia " + diaAtual + " - Manhã: " + obterDescricaoLocalDoDia(diaAtual) + "\nO que você faz?");
            }
        }
    }
    
    public String obterNomeLocalDoDia(int dia) {
        return switch (dia) {
            case 1 -> "Distrito Residencial - Bairro Esperança";
            case 2 -> "Posto de Polícia - Patrulha Silenciosa";
            case 3 -> "Hospital - Santa Vida";
            case 4 -> "Fábrica Abandonada - Metalúrgica Norte";
            case 5 -> "Parque Industrial - Zona Sombria";
            case 6 -> "Base Militar - Fortaleza Eclipse";
            case 7 -> "Ponto Alfa - Ponto Alfa";
            default -> "Desconhecido";
        };
    }
    
    public String obterDescricaoLocalDoDia(int dia) {
        return switch (dia) {
            case 1 -> "As casas estão vazias, portas rangem com o vento e o silêncio é quase perturbador. A sensação é de que a qualquer momento algo pode espreitar das sombras.";
            case 2 -> "Documentos espalhados, rádios quebrados e marcas de luta sugerem que a rotina da lei terminou de forma abrupta e violenta.";
            case 3 -> "Corredores estreitos, cheiro de mofo e equipamentos médicos enferrujados criam uma atmosfera sufocante, onde cada som ecoa como um aviso.";
            case 4 -> "Máquinas enferrujadas, esteiras paradas e o som metálico ocasional ecoam, como se o prédio tivesse memória própria.";
            case 5 -> "Galpões gigantes e estruturas abandonadas formam um labirinto industrial onde a escuridão domina cada canto.";
            case 6 -> "Fortificações imponentes, arame farpado e torres de vigia vazias passam a sensação de vigilância constante, mesmo sem ninguém por perto.";
            case 7 -> "O ambiente transmite tensão imediata: cada passo parece ecoar mais alto, como se fosse impossível permanecer despercebido.";
            default -> "Um lugar estranho, com uma atmosfera que causa desconforto imediato.";
        };
    }   

    public boolean todasExploracoesConcluidas() {
        return exploracoesDiaAtual >= 3;
    }

    public void avancarPeriodo() {
        periodoAtual = periodoAtual.proximo();
        
        // Limpar sublocal atual se o período avançou para um novo dia (Manhã)
        if (periodoAtual == PeriodoDia.MANHA) {
            subLocalAtual = null;
        }
        // A mensagem de avanço de período será gerada no ControladorJogo
    }

    public boolean podeDormir() {
        return !eventoFinalAtivo && !emCombate && exploracoesDiaAtual >= 3 && !dormiu;
    }

    public boolean podeExplorar() {
        return !eventoFinalAtivo && !emCombate && exploracoesDiaAtual < 3 && !dormiu;
    }

    public boolean podeSelecionarSubLocal() {
        return emSelecaoSubLocal && localAtual != null && !localAtual.getSubLocais().isEmpty();
    }

    // ===== GETTERS PARA A INTERFACE =====
    public boolean isDormiu() { return dormiu; }
    public int getExploracoesDiaAtual() { return exploracoesDiaAtual; }

    // ===== GETTERS/SETTERS EXISTENTES =====
    public Personagem getJogador() { return jogador; }
    public int getDiaAtual() { return diaAtual; }
    public PeriodoDia getPeriodoAtual() { return periodoAtual; }
    public boolean isEmCombate() { return emCombate; }
    public void setEmCombate(boolean emCombate) { this.emCombate = emCombate; }
    public Local getLocalAtual() { return localAtual; }
    public void setLocalAtual(Local localAtual) { this.localAtual = localAtual; }
    public List<Local> getLocaisDoDia() { return new ArrayList<>(locaisDoDia); }

    // Novo método para obter locais disponíveis para seleção nos dias intermediários
    public List<Local> getLocaisDisponiveisParaSelecao() {
        List<Local> disponiveis = new ArrayList<>(locaisBase);
        disponiveis.remove(localDia1Fixo);
        disponiveis.remove(localDia7Fixo);
        return disponiveis;
    }

    public List<Local> getLocaisBase() { return new ArrayList<>(locaisBase); }
    public List<Local> getLocais() { return getLocaisDoDia(); }
    public List<Zumbi> getInimigosAtuais() { return inimigosAtuais; }
    public void setInimigosAtuais(List<Zumbi> lista) { this.inimigosAtuais = lista; }
    public boolean isJogoTerminado() { return jogoTerminado; }
    public void setJogoTerminado(boolean jogoTerminado) { this.jogoTerminado = jogoTerminado; }
    public boolean isJogoVencido() { return jogoVencido; }
    public void setJogoVencido(boolean jogoVencido) { this.jogoVencido = jogoVencido; }
    public String getMensagem() { return mensagem; }
    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }
    public boolean isEventoFinalAtivo() { return eventoFinalAtivo; }
    public void setEventoFinalAtivo(boolean ativo) { this.eventoFinalAtivo = ativo; }
    public boolean isEmSelecaoSubLocal() { return emSelecaoSubLocal; }
    public SubLocal getSubLocalAtual() { return subLocalAtual; }
    public void setSubLocalAtual(SubLocal subLocalAtual) { this.subLocalAtual = subLocalAtual; }
    public String getResumoDiaAnterior() { return resumoDiaAnterior; }
    public void setResumoDiaAnterior(String resumoDiaAnterior) { this.resumoDiaAnterior = resumoDiaAnterior; }

    // NOVO: Método para gerar mensagens da noite com base no sentimento
    public String gerarMensagemNoite(String sentimento) {
        // Mensagem neutra para o final do dia, focando no descanso e esperança
        return "Você se preparou para descansar, na esperança de um dia melhor.\n";
    }

    // NOVO: Método para atualizar o sentimento do jogador (REMOVIDO - AGORA ESTÁ EM PERSONAGEM.JAVA)
    // public void atualizarSentimentoJogador(int intensidadeEvento) { ... }
}